= Source to Image
include::_attributes.adoc[]

[#introduction]
== Introduction to S2I

Another approach to developing for OpenShift is Source-to-Image. s2i is a tool provided by Red Hat that enables you to include additional information in your source code project, and to build a container image and run your code on-demand.


NOTE: The Source-to-Image s2i build command has a dependency on a local Docker service. This guide uses RHEL 8 and Podman (no Docker) explicitly. Therefore, there is a subtle difference using the --as-dockerfile option and an extra `podman` build step.

S2I is nothing more than an opinionated approach to building container images.

In the case of a Python example, start with a clean base image, s2i adds application specific dependencies. For example, you might take a minimal RHEL8 base image then create a new "S2I" image, adding Python, PIP and use PIP to install FastAPI.

This new Python/FastAPI builder image can be then consumed, only needing to add your code and a run script, reducing the time to deploy an application (because Python & required packages are already staged in the image). The less extra stuff to do in the final application image builds, the faster to deploy.

[source%nowrap,console]
----
── Base Image
   └── Builder Image
       └── Application Image
----

You can think of the process as a basic build pipeline. Most enterprises already have more sophisticated build pipelines in place. A term often used is an "Image Bakery". Final application images ready for consumption in some image registry.

However, Source-to-Image comes out-of-the-box with OpenShift and provides a convenient method for developers to override, assemble, and run scripts. The scripts, as mentioned earlier, can be included in a source code repository along with source code. Source-to-Image empowers the developer to include additional packages and custom commands while still consuming standard base or custom build images. 

[#s2i_binary]
=== Get si2 binary

image::s2i_overview.png[]

[source%nowrap,console]
----
wget https://github.com/openshift/source-to-image/releases/download/v1.3.1/source-to-image-v1.3.1-a5a77147-linux-amd64.tar.gz
----

[source%nowrap,console]
----
tar -xvf source-to-image-v1.3.1-a5a77147-linux-amd64.tar.gz .
----

[source%nowrap,console]
----
mv s2i ~/bin
----

[source%nowrap,console]
----
s2i version

s2i v1.3.1
----

[#s2i_explore]
=== Explore UBI

Assuming you have access to a registry containing UBI images (use `podman login`), you can search the registry, for example:

[source%nowrap,console]
----
podman search registry.redhat.io/ubi8
----

Pull the `python-36` base image as needed.

[source%nowrap,console]
----
podman pull registry.redhat.io/ubi8/python-36
----

[source%nowrap,console]
----
podman images
REPOSITORY                          TAG      IMAGE ID       CREATED       SIZE
registry.redhat.io/ubi8/python-36   latest   88189ceb8a67   5 weeks ago   825 MB
----

Our example is concerned with the python-36 image.

You can validate that this is indeed an s2i primed image:

[source%nowrap,console]
----
podman inspect --format='{{ index .Config.Labels "io.openshift.s2i.scripts-url"}}' registry.redhat.io/ubi8/python-36
----

You should see the following output, which confirms the image includes `s2i`: 

[source%nowrap,console]
----
image:///usr/libexec/s2i
----

Explore the container:

[source%nowrap,console]
----
podman run --name test -it registry.redhat.io/ubi8/python-36 bash
----

You'll find the following directories and files are present:

[source%nowrap,console]
----
/usr/libexec/s2i/assemble
/usr/libexec/s2i/run
/usr/libexec/s2i/usage
----

Python and PIP are already installed (because this is the `python-36` base image):

[source%nowrap,console]
----
(app-root) python -V
Python 3.6.8
(app-root) pip -V
pip 21.0.1 from /opt/app-root/lib/python3.6/site-packages/pip (python 3.6)
----

[#s2i_example]
=== FastAPI example

==== S2I base image

Starting with a blank canvas, create a new working directory:

[source%nowrap,console]
----
mkdir ~/source-to-image 
cd ~/source-to-image 
----

Use s2i create <image_name> <directory> to start a new project:

[source%nowrap,console]
----
s2i create s2i-fastapi s2i-fastapi
cd s2i-django
----

The command create the following skeleton structure:

[source%nowrap,console]
----
.
├── Dockerfile
├── Makefile
├── README.md
├── s2i
│   └── bin
│       ├── assemble
│       ├── run
│       ├── save-artifacts
│       └── usage
└── test
    ├── run
    └── test-app
        └── index.html
----

You can remove the test directory.

[source%nowrap,console]
----
rm -rf test/
----

The `Dockerfile` generated is a handy reference, here is a working example for this guide:

[source%nowrap,console]
----
vi Dockerfile
----

[source%nowrap,console]
----
FROM ubi8/python-36

LABEL maintainer="Richard Walker <rwalker@redhat.com>"

LABEL io.k8s.description="Platform for building FastAPI applications" \
      io.k8s.display-name="builder 0.0.1" \
      io.openshift.expose-services="8000:http" \
      io.openshift.tags="builder,python,python36"

USER root

RUN yum -y update && \
    yum clean all
RUN pip install --upgrade pip
RUN pip3 install fastapi

COPY ./s2i/bin/ /usr/libexec/s2i

RUN chown -R 1001:1001 /opt/app-root

USER 1001

EXPOSE 8000

CMD ["/usr/libexec/s2i/usage"]
----

Add additional application build tasks in `s2i/bin/assemble`, for purposes of demonstration, here the `fastapi` package is duplicated (that package is already being installed in the `Dockerfile`), however, the addition `unicorn` package is appended:

[source%nowrap,console]
----
#!/bin/bash -e

# If the 's2i-fastapi' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
	exec /usr/libexec/s2i/usage
fi

# Install requirements
echo "---> Building application from source..."

pip install fastapi uvicorn
----

This will result in the `fastapi` dependency being already satisfied, making the build faster. Next, add the following to `s2i/bin/run`, so `s2i` knows how to run the application:

[source%nowrap,console]
----
#!/bin/bash -e
#
# S2I run script for the 's2i-fastapi' image.
# The run script executes the server that runs your application.
#
# For more information see the documentation:
#	https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#

python main.py
----

Build the image: 

[source%nowrap,console]
----
podman build -t local/fastapi-s2i-base-img .
----

==== Build application from S2I

Create a new working directory:

[source%nowrap,console]
----
mkdir s2i-fastapi-build
----

The following command with "stage" the S2I image build: 

[source%nowrap,console]
----
s2i build https://github.com/rwalker-redhat/fastapi-quickstart.git fastapi-s2i-base-img --as-dockerfile Dockerfile
----

You can explore the contents of the generated `Dockerfile` and files staged files in `uploads`, to build a new application image using your custom s2i image: 

[source%nowrap,console]
----
buildah bud -t local/fastapi-s2i-base-img .
----

And run the container:

[source%nowrap,console]
----
podman run --name myapp -u 1001 -d -p 8000:8000 -e ENV_SECRET="hello-s2i" local/fastapi-s2i-base-img
----

The container will fail to launch due to missing packages:

[source%nowrap,console]
----
podman logs b9fc63c55e37


Traceback (most recent call last):
  File "main.py", line 4, in <module>
    from views import home # New
  File "/opt/app-root/src/views/home.py", line 10, in <module>
    templates = Jinja2Templates('templates')
  File "/opt/app-root/lib/python3.6/site-packages/starlette/templating.py", line 58, in __init__
    assert jinja2 is not None, "jinja2 must be installed to use Jinja2Templates"
AssertionError: jinja2 must be installed to use Jinja2Templates
----

So far, the `fastapi` package was included in the original base image build, and therefore satisfied. Secondly, `fastapi` and `uvicorn` where included int he s2i `assemble` script. But we still need `jinja2`, `aiofiles`, and `environs` for the application to run. 

You could go back a stage and include them in the local `s2i/bin/assemble` and rebuild the image, or you have the option to include `s2i/bin/assemble` in the code project, that would over ride and take precedence.  

Hopefully it's becoming a little clearer, that all S2i does is enable images to be preloaded with build and execution steps for certain types of applications. The degree of this "preloading" will vary, the less done, the more generic and image, thus requiring longer build/deploy times, the greater "pre-loading/configuration" the more specific use cases, but faster build/deploy times. 

Go ahead and add the following to the code project: 

[source%nowrap,console]
----
mkdir -p .s2i/bin/
vi s2i/bin/assemble
----

[source%nowrap,console]
----
#!/bin/bash -e

# If the 's2i-fastapi' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
	exec /usr/libexec/s2i/usage
fi

echo "---> Installing application source..."
cp -Rf /tmp/src/. /opt/app-root/src
echo "---> Fixing persmissions..."
chmod -R 775 ./

# Install requirements
echo "---> Building application from source..."

pip install fastapi uvicorn jinja2 aiofiles environs
----

Now repeat the S2I build:

[source%nowrap,console]
----
s2i build https://github.com/rwalker-redhat/fastapi-quickstart.git fastapi-s2i-base-img --as-dockerfile Dockerfile
----

[source%nowrap,console]
----
buildah bud -t local/fastapi-s2i-base-img .
----

[source%nowrap,console]
----
podman run --name myapp -u 1001 -d -p 8000:8000 -e ENV_SECRET="hello-s2i" local/fastapi-s2i-base-img
----

And all should be working.

==== Quickstart

The S2I quick-start is at the end of this page, because now you may have a fighting chance of understanding what is happening when invoking a generic s2i build.

Most out-of-the-box Python s2i images have no understanding of how to run the FastAPI application demonstration in this guide using `python main.py`. But now it should be pretty obvious, all that is required is the inclusion of `.s2i/bin/assemble` and `.s2i/bin/run` in the project. Standard s2i images should look for and execute a `pip install -r requirements.txt` if included in your project, or simply use that command in the `assemble` script`. Again, perfectly common approach to handling Python packages. 

With these fundamentals of using s2i images, some confidence can be had taking a universal base image, including and tweaking `assemble` and `run`scripts along side you code and deploying you application: 

Create a new project:

[source%nowrap,console]
----
oc new-project fast-example
----

Deploy source code using a Python UBI image:

[source%nowrap,console]
----
oc new-app registry.access.redhat.com/ubi8/python-38~https://github.com/rwalker-redhat/fastapi-quickstart.git -e ENV_SECRET="New Deployment from CLI"
----

Expose a route:

[source%nowrap,console]
----
oc expose service/fastapi-quickstart --port=8000
----

Services created using s2i default to port 8080, the following command is very useful to patch an existing service, in this case changing it to port 8000:

[source%nowrap,console]
----
oc patch svc fastapi-quickstart --type merge --patch '{"spec":{"ports":[{"port": 8000, "targetPort": 8000 }]}}'
----

See https://github.com/sclorg/s2i-python-container for probably the best Python s2i images available. 